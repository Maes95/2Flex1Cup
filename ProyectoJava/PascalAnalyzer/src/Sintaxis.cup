import java_cup.runtime.*;

/* ------------ CÓDIGO AÑADIDO PARA MOSTRAR ERRORES ----------- */

parser code {:

    public void report_error(String mensajeError, Object token) {

                 StringBuilder salidaError = new StringBuilder("Error");

                 if (token instanceof java_cup.runtime.Symbol) {

                     java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) token);

                     if (s.left >= 0) {
                         salidaError.append(" en la linea "+(s.left));
                         if (s.right >= 0)
                             salidaError.append(", columna "+(s.right));
                     }

                     if (s.value != null){
                         salidaError.append(". El token <"+s.value.toString()+"> no se ajusta a la sintaxis");
                     }

                 }

        salidaError.append(" : " + mensajeError);

        System.out.println(salidaError);
    }

    /* Método para errores irrecuperables */

    public void unrecovered_syntax_error(Symbol token) throws java.lang.Exception {
      report_fatal_error("El analizador no pudo recuperarse del error sintactico", token);
    }

    public void report_fatal_error(String mensajeError, Object token) {
        mensajeError = "Error sintactico irrecuperable\n" + mensajeError;
        report_error(mensajeError, token);
        System.exit(1);
    }

    /* Método para errores recuperables */

    public void syntax_error(Symbol token) {
      report_error("Error sintactico.\nSe procedera a intentar continuar con el analisis sintactico", token);
    }

:};

/* ------------ DECLARACIÓN DE TERMINALES ----------- */

terminal program, begin, end, var, const_t, if_t, then_t, else_t, while_t, for_t, to, do_t, case_t, of, function, procedure, type, int_name, real_name, char_name,
          semicolons, colons, asig, equal, comma, point, open_bracket, close_bracket, open_square_bracket, close_square_bracket, comparator_op,
          not_op, decimal_value, hexadecimal_value, string_literal, identifier, plus, minus, product, div_op, mod_op, and_op, or_op, two_points, array, record;

/* ------------ DECLARACIÓN DE NO TERMINALES ----------- */

non terminal PRG, BLQ, DCLLIST, SENTLIST, DCL, DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST, DEFPROC, DEFFUN, FORMAL_PARAMLIST, FORMAL_PARAM,
              TBAS, SENT, ASIG, ID, EXP, OP, OPCOMP, OPARIT, OPLOG, FACTOR, SUBPARAMLIST, EXPLIST, PROC_CALL, EXEBLQ, DCLLIST_BLQ, DCL_BLQ, DEFTYPE, TYPELIST, UDTYPE, ALLTYPES,
              COND, ELSECOND, WLOOP, FLOOP, CASE, CASELIST;

/* ------------ DECLARACIÓN DE PRECEDENCIA  ----------- */

precedence left comparator_op;
precedence left plus, minus, or_op;
precedence left product, div_op, mod_op, and_op;
precedence left open_bracket, close_bracket;
precedence left else_t;
/*precedence nonassoc EQUALS;*/

/* ------------ SINTAXIS BÁSICA  ----------- */

PRG::= program identifier:i1 semicolons BLQ point {: System.out.println("PRG <program "+i1+" ; BLQ .>"); :};
BLQ::= DCLLIST begin SENTLIST end {: System.out.println("BLQ <DCLLIST begin SENTLIST end>"); :};

DCLLIST::=              {: System.out.println("DCLLIST <lambda>"); :}
          | DCLLIST DCL {: System.out.println("DCLLIST <DCLLIST DCL>"); :}
          ;

SENTLIST::= SENT {: System.out.println("SENTLIST <SENT>"); :}
          | SENTLIST SENT {: System.out.println("SENTLIST <SENTLIST SENT>"); :}
          ;

DCL::= DEFCTE   {: System.out.println("DCL <DEFCTE>"); :}
      | DEFVAR  {: System.out.println("DCL <DEFVAR>"); :}
      | DEFPROC {: System.out.println("DCL <DEFPROC>"); :}
      | DEFFUN  {: System.out.println("DCL <DEFFUN>"); :}
      | DEFTYPE {: System.out.println("DCL <DEFTYPE>"); :}
      ;

DEFCTE::= const_t CTELIST {: System.out.println("DEFCTE <const CTELIST>"); :};

CTELIST::= identifier:i1 equal SIMPVALUE semicolons {: System.out.println("CTELIST <" +i1+" = SIMPVALUE ;>"); :}
          | CTELIST identifier:i2 equal SIMPVALUE semicolons {: System.out.println("CTELIST <CTELIST "+i2+" = SIMPVALUE ;>"); :}
          ;

SIMPVALUE::= decimal_value:dv    {: System.out.println("REDUCIDO SIMVALUE: " + dv ); :}
          | hexadecimal_value:hv {: System.out.println("REDUCIDO SIMVALUE: " + hv ); :}
          | string_literal:sl    {: System.out.println("REDUCIDO SIMVALUE: " + sl ); :}
          ;

DEFVAR::= var DEFVARLIST semicolons {: System.out.println("DEFVAR <var DEFVARLIST ;>"); :};

DEFVARLIST::= VARLIST colons ALLTYPES                        {: System.out.println("DEFVARLIST <VARLIST : ALLTYPES>"); :}
             | DEFVARLIST semicolons VARLIST colons ALLTYPES {: System.out.println("DEFVARLIST <DEFVARLIST ; VARLIST : ALLTYPES>"); :}
             ;

VARLIST::= identifier:i1                 {: System.out.println("REDUCIDO VARLIST: " + i1); :}
           | identifier:i2 comma VARLIST {: System.out.println("VARLIST <"+i2+" , VARLIST>"); :}
           ;

DEFPROC::=  procedure identifier:i1 FORMAL_PARAMLIST semicolons BLQ semicolons {: System.out.println("DEFPROC <procedure "+i1+" FORMAL_PARAMLIST ; BLQ ;>"); :};
DEFFUN::=  function identifier:i2 FORMAL_PARAMLIST colons ALLTYPES semicolons BLQ semicolons {: System.out.println("DEFFUN <function "+i2+" FORMAL_PARAMLIST : ALLTYPES ; BLQ ;>"); :};

FORMAL_PARAMLIST::=                                           {: System.out.println("FORMAL_PARAMLIST <lambda>"); :}
                    | open_bracket FORMAL_PARAM close_bracket {: System.out.println("FORMAL_PARAMLIST <( FORMAL_PARAM )>"); :}
                    ;

FORMAL_PARAM::= VARLIST colons ALLTYPES                          {: System.out.println("FORMAL_PARAM <VARLIST : ALLTYPES>"); :}
               | VARLIST colons ALLTYPES semicolons FORMAL_PARAM {: System.out.println("FORMAL_PARAM <VARLIST : ALLTYPES ; FORMAL_PARAM>"); :}
               ;

TBAS::= int_name    {: System.out.println("REDUCIDO TBAS: INTEGER"); :}
        | real_name {: System.out.println("REDUCIDO TBAS: REAL"); :}
        | char_name {: System.out.println("REDUCIDO TBAS: CHAR"); :}
        ;

SENT::= ASIG semicolons         {: System.out.println("SENT <ASIG ;>"); :}
        | PROC_CALL semicolons  {: System.out.println("SENT <PROC_CALL ;>"); :}
        | EXEBLQ                {: System.out.println("SENT <EXEBLQ>"); :}
        | COND                  {: System.out.println("SENT <COND>"); :}
        | WLOOP                 {: System.out.println("SENT <WLOOP>"); :}
        | FLOOP                 {: System.out.println("SENT <FLOOP>"); :}
        | CASE                  {: System.out.println("SENT <CASE>"); :}
        | error SENT            {: System.out.println("Recuperacion de error satisfactoria en SENT"); :}
        ;

ASIG::= ID asig EXP {: System.out.println("ASIG <ID := EXP>"); :};

ID::= identifier:i1                                                {: System.out.println("REDUCIDO ID: "+i1); :}
      | identifier:i4 open_square_bracket EXP close_square_bracket {: System.out.println("ID <"+i4+" [ EXP ]>"); :}
      | identifier:i2 point identifier:i3                          {: System.out.println("REDUCIDO ID: "+i2+"."+i3); :}
      ;

EXP::= EXP OP EXP {: System.out.println("EXP <EXP OP EXP>"); :}
       | FACTOR   {: System.out.println("EXP <FACTOR>"); :}
       ;

OP::= OPCOMP   {: System.out.println("OP <OPCOMP>"); :}
      | OPLOG  {: System.out.println("OP <OPLOG>"); :}
      | OPARIT {: System.out.println("OP <OPARIT>"); :}
      ;

OPCOMP::= comparator_op:op {: System.out.println("OPCOMP <"+op+">"); :}; /* MIRAR */

OPARIT::= plus       {: System.out.println("REDUCIDO OPARIT: +"); :}
          | minus    {: System.out.println("REDUCIDO OPARIT: -"); :}
          | product  {: System.out.println("REDUCIDO OPARIT: *"); :}
          | div_op   {: System.out.println("REDUCIDO OPARIT: div"); :}
          | mod_op   {: System.out.println("REDUCIDO OPARIT: mod"); :}
          ;


OPLOG::= and_op    {: System.out.println("REDUCIDO OPLOG: and"); :}
          | or_op  {: System.out.println("REDUCIDO OPLOG: or"); :}
          ;

FACTOR::= SIMPVALUE                                                      {: System.out.println("FACTOR <SIMPVALUE>"); :}
          | not_op FACTOR                                                {: System.out.println("FACTOR <not FACTOR>"); :}
          | open_bracket EXP close_bracket                               {: System.out.println("FACTOR <( EXP )>"); :}
          | identifier:i1 SUBPARAMLIST                                   {: System.out.println("FACTOR <"+i1+" SUBPARAMLIST>"); :}
          | identifier:i2 open_square_bracket EXP close_square_bracket   {: System.out.println("FACTOR <"+i2+" [ EXP ]>"); :}
          | identifier:i3 point identifier:i4                            {: System.out.println("FACTOR <"+i3+" . "+i4+">"); :}
          ;

SUBPARAMLIST::=                                      {: System.out.println("SUBPARAMLIST <lambda>"); :}
                | open_bracket EXPLIST close_bracket {: System.out.println("SUBPARAMLIST <( EXPLIST )>"); :}
                ;

EXPLIST::= EXP                {: System.out.println("EXPLIST <EXP>"); :}
          | EXP comma EXPLIST {: System.out.println("EXPLIST <EXP , EXPLIST>"); :}
          ;

PROC_CALL::= identifier:i1 SUBPARAMLIST {: System.out.println("PROC_CALL <"+i1+" SUBPARAMLIST>"); :};
EXEBLQ::= DCLLIST_BLQ begin SENTLIST end {: System.out.println("EXEBLQ <DCLLIST_BLQ begin SENTLIST end>"); :};

DCLLIST_BLQ::=                                   {: System.out.println("DCLLIST_BLQ <lambda>"); :}
               | DCLLIST_BLQ semicolons DCL_BLQ  {: System.out.println("DCLLIST_BLQ <DCLLIST_BLQ ; DCL_BLQ>"); :}
               ;

DCL_BLQ::= DEFCTE    {: System.out.println("DCL_BLQ <DEFCTE>"); :}
           | DEFVAR  {: System.out.println("DCL_BLQ <DEFVAR>"); :}
           | DEFTYPE {: System.out.println("DCL_BLQ <DEFTYPE>"); :}
           ;

/* ------------ SINTAXIS ESTRUCTURAS DE DATOS  ----------- */

DEFTYPE ::= type TYPELIST {: System.out.println("DEFTYPE <type TYPELIST>"); :};

TYPELIST ::= identifier:i1 equal UDTYPE semicolons              {: System.out.println("TYPELIST <"+i1+" = UDTYPE ;>"); :}
              | identifier:i2 equal UDTYPE semicolons TYPELIST  {: System.out.println("TYPELIST <"+i2+" = UDTYPE ; TYPELIST>"); :}
              ;

UDTYPE ::= array open_square_bracket SIMPVALUE two_points SIMPVALUE close_square_bracket of ALLTYPES {: System.out.println("UDTYPE <array [ SIMPVALUE .. SIMPVALUE ] of ALLTYPES>"); :}
              | record DEFVARLIST end                                                                {: System.out.println("UDTYPE <record DEFVARLIST end>"); :}
              ;

ALLTYPES ::= TBAS            {: System.out.println("ALLTYPES <TBAS>"); :}
             | identifier:i  {: System.out.println("REDUCIDO ALLTYPES: "+i); :}
             ;

/* ------------ SINTAXIS SENTENCIAS DE CONTROL DE FLUJO  ----------- */

                         /* SENTENCIA IF */

COND ::= if_t EXP then_t SENT ELSECOND {: System.out.println("COND <if EXP then SENT ELSECOND>"); :};

ELSECOND ::=               {: System.out.println("ELSECOND <lambda>"); :}
            | else_t SENT  {: System.out.println("ELSECOND <else SENT>"); :}
            ;

                        /* SENTENCIA WHILE */

WLOOP ::= while_t EXP do_t SENT {: System.out.println("WLOOP <while EXP do SENT>"); :};

                        /* SENTENCIA FOR  */

FLOOP ::= for_t identifier:i1 asig EXP to EXP do_t SENT {: System.out.println("FLOOP <for "+i1+" := EXP to EXP do SENT>"); :};

                        /* SENTENCIA CASE */

CASE ::= case_t EXP of CASELIST end {: System.out.println("CASE <case EXP of CASELIST end>"); :};

CASELIST ::= EXP colons SENT            {: System.out.println("CASELIST <EXP : SENT>"); :}
             | EXP colons SENT CASELIST {: System.out.println("CASELIST <EXP : SENT CASELIST>"); :}
             ;
