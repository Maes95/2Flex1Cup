import java_cup.runtime.*;
import java.util.Stack;

/* ------------ CODIGO AÑADIDO PARA MOSTRAR EL ARBOL -----------*/

init with {:
  // INIT CODE
  // Codigo para inicializar
  System.out.println("---------------------------------------------------------------------\n"
                    +"|       ANALIZADOR LEXICO Y SINTACTICO PARA LEGUAJE PASCAL          |\n"
                    +"---------------------------------------------------------------------\n");
  this.stack = new Stack<>();
  this.htmlGenerator = new HTMLGenerator();
:};

action code {:
  // ACTION CODE
  // Codigo para métodos
  public void pushRegla(String cadena){
    System.out.println(cadena);
    Regla regla = new Regla(cadena);
    stack.push(regla);
  }

  public void mostrarArbol(String cadena){
    System.out.println(cadena + "\n");
    Regla regla = new Regla(cadena);
    stack.push(regla);
    System.out.println("---------------------------------------------------------------------\n"
                      +"|                    ARBOL SINTACTICO GENERADO                      |\n"
                      +"---------------------------------------------------------------------\n");
    System.out.println("_" + regla.antecedente);
    Regla.printSyntacticTree(stack, ""); // Pinta el arbol sintáctico (ver clase "Regla")
  }

:};

/* ------------ CODIGO AÑADIDO PARA MOSTRAR ERRORES ----------- */

parser code {:

    Stack<Regla> stack; // Pila donde se almacenan las reglas que se han reducido

    HTMLGenerator htmlGenerator;

    public void report_error(String mensajeError, Object token) {

                 StringBuilder salidaError = new StringBuilder("ERROR SINTACTICO: ");

                 if (token instanceof java_cup.runtime.Symbol) {

                     java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) token);

                     if (s.left >= 0) {
                         salidaError.append(" en la linea "+(s.left + 1));
                         if (s.right >= 0)
                             salidaError.append(", columna "+(s.right));
                     }

                     if (s.value != null){
                         salidaError.append(". No se esperaba el token <"+s.value.toString()+">");
                     }

                 }

        salidaError.append(" : " + mensajeError);

        System.err.println(salidaError);
    }

    /* Método para errores irrecuperables */

    public void unrecovered_syntax_error(Symbol token) throws java.lang.Exception {
      report_fatal_error("El analizador no pudo recuperarse del error sintactico", token);
    }

    public void report_fatal_error(String mensajeError, Object token) {
        mensajeError = "Error sintactico irrecuperable\n" + mensajeError;
        report_error(mensajeError, token);
        System.exit(1);
    }

    /* Método para errores recuperables */

    public void syntax_error(Symbol token) {
      report_error("Se procedera a intentar continuar con el analisis sintactico", token);
    }

:};

/* ------------ DECLARACIÓN DE TERMINALES ----------- */

terminal String program, begin, end, var, const_t, if_t, then_t, else_t, while_t, for_t, to, do_t, case_t, of, function, procedure, type, int_name, real_name, char_name,
          semicolons, colons, asig, equal, comma, point, open_bracket, close_bracket, open_square_bracket, close_square_bracket, comparator_op,
          not_op, decimal_value, hexadecimal_value, string_literal, plus, minus, product, div_op, mod_op, and_op, or_op, two_points, array, record;

terminal String identifier;
/* ------------ DECLARACIÓN DE NO TERMINALES ----------- */

non terminal String PRG, BLQ, DCLLIST, SENTLIST, DCL, DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST, DEFPROC, DEFFUN, FORMAL_PARAMLIST, FORMAL_PARAM,
              TBAS, SENT, ASIG, ID, EXP, OP, OPCOMP, OPARIT, OPLOG, FACTOR, SUBPARAMLIST, EXPLIST, PROC_CALL, EXEBLQ, DCLLIST_BLQ, DCL_BLQ, DEFTYPE, TYPELIST, UDTYPE, ALLTYPES,
              COND, ELSECOND, WLOOP, FLOOP, CASE, CASELIST;

/* ------------ DECLARACIÓN DE PRECEDENCIA  ----------- */

precedence left comparator_op;
precedence left plus, minus, or_op;
precedence left product, div_op, mod_op, and_op;
precedence left open_bracket, close_bracket;
precedence left else_t;

/* ------------ SINTAXIS BÁSICA  ----------- */

PRG::= program identifier:i1 semicolons BLQ:blq point {: mostrarArbol("PRG <%program "+i1+" ; BLQ .%>");
                                                         htmlGenerator.nameProgram = i1;
                                                         htmlGenerator.closeHTML();:};
BLQ::= DCLLIST:dcllist begin{:htmlGenerator.identLevel++;:} SENTLIST:sentlist end
                                                      {: htmlGenerator.identLevel--;
                                                      pushRegla("BLQ <%DCLLIST begin SENTLIST end%>");
                                                      htmlGenerator.getMainProgram(sentlist);
                                                      RESULT = dcllist + "<br/>" + htmlGenerator.getReservedWord("begin") + sentlist + htmlGenerator.getReservedWord("end");:};

DCLLIST::=                          {: pushRegla("DCLLIST <%lambda%>");
                                       RESULT = "";:}
          | DCLLIST:dcllist DCL:dcl {: pushRegla("DCLLIST <%DCLLIST DCL%>");
                                       htmlGenerator.updateLastDcl(dcl);
                                       RESULT = dcllist + (String)dcl;:}
          ;

SENTLIST::= {: htmlGenerator.sentCond = false; :} SENT:sent    {: pushRegla("SENTLIST <%SENT%>"); // Hay mas de una sentencia
                                                                  RESULT = sent;:}
          | SENTLIST:sentlist SENT:sent {: pushRegla("SENTLIST <%SENTLIST SENT%>");
                                           RESULT = sentlist + (String)sent;:}
          | error
          ;

DCL::= DEFCTE:defcte   {: pushRegla("DCL <%DEFCTE%>");
                          RESULT = defcte;:}
      | DEFVAR:defvar  {: pushRegla("DCL <%DEFVAR%>");
                          RESULT = defvar;:}
      | DEFPROC:defproc {: pushRegla("DCL <%DEFPROC%>");
                           RESULT = defproc;:}
      | DEFFUN:deffun  {: pushRegla("DCL <%DEFFUN%>");
                          RESULT = deffun;:}
      | DEFTYPE:deftype {: pushRegla("DCL <%DEFTYPE%>");
                           RESULT = deftype;:}
      | error
      ;

DEFCTE::= const_t CTELIST:ctelist {: pushRegla("DEFCTE <%const CTELIST%>");
                                     RESULT = htmlGenerator.getReservedWord("const") + ctelist;:};

CTELIST::= identifier:i1 equal SIMPVALUE:simpvalue semicolons {: pushRegla("CTELIST <%" +i1+" = SIMPVALUE ;%>");
                                                                 RESULT = htmlGenerator.getIdent(i1) + "=" + simpvalue + ";";:}
          | CTELIST:ctelist identifier:i2 equal SIMPVALUE:simpvalue semicolons {: pushRegla("CTELIST <%CTELIST "+i2+" = SIMPVALUE ;%>");
                                                                                  RESULT = (String)ctelist + htmlGenerator.getIdent(i2) + "=" + (String)simpvalue + ";";:}
          ;

SIMPVALUE::= decimal_value:dv    {: pushRegla("SIMVALUE <%" + dv + "%>" );
                                    RESULT = htmlGenerator.getConst(dv);:}
          | hexadecimal_value:hv {: pushRegla("SIMVALUE <%" + hv + "%>");
                                    RESULT = htmlGenerator.getConst(hv);:}
          | string_literal:sl    {: pushRegla("SIMVALUE <%" + sl + "%>");
                                    RESULT = htmlGenerator.getConst(sl);:}
          ;

DEFVAR::= var DEFVARLIST:defvarlist semicolons {: pushRegla("DEFVAR <%var DEFVARLIST ;%>");
                                                  RESULT = htmlGenerator.getReservedWord("var ") + defvarlist + "; ";:};

DEFVARLIST::= VARLIST:varlist colons ALLTYPES:alltypes                                   {: pushRegla("DEFVARLIST <%VARLIST : ALLTYPES%>");
                                                                                            RESULT = varlist + " : " + alltypes;:}
             | DEFVARLIST:defvarlist semicolons VARLIST:varlist colons ALLTYPES:alltypes {: pushRegla("DEFVARLIST <%DEFVARLIST ; VARLIST : ALLTYPES%>");
                                                                                            RESULT = defvarlist + "; " + varlist + " : " + alltypes;:}
             ;

VARLIST::= identifier:i1                         {: pushRegla("VARLIST <%" + i1 + "%>");
                                                    RESULT = htmlGenerator.getIdent(i1);:}
           | identifier:i2 comma VARLIST:varlist {: pushRegla("VARLIST <%"+ i2 +" , VARLIST%>");
                                                    RESULT = htmlGenerator.getIdent(i2) + "," + varlist;:}
           ;

DEFPROC::=  procedure identifier:i1 FORMAL_PARAMLIST:formal_paramlist semicolons BLQ:blq semicolons {:
                    pushRegla("DEFPROC <%procedure "+ i1 +" FORMAL_PARAMLIST ; BLQ ;%>");
                    RESULT = htmlGenerator.getProc(i1, formal_paramlist, blq);:};
DEFFUN::=  function identifier:i2 FORMAL_PARAMLIST:formal_paramlist colons ALLTYPES:alltypes semicolons BLQ:blq semicolons {:
                    pushRegla("DEFFUN <%function "+i2+" FORMAL_PARAMLIST : ALLTYPES ; BLQ ;%>");
                    RESULT = htmlGenerator.getFunc(i2, formal_paramlist, alltypes, blq);:};

FORMAL_PARAMLIST::=                                                        {: pushRegla("FORMAL_PARAMLIST <%lambda%>");
                                                                              RESULT = "";:}
                    | open_bracket FORMAL_PARAM:formal_param close_bracket {: pushRegla("FORMAL_PARAMLIST <%( FORMAL_PARAM )%>");
                                                                              RESULT = "(" + formal_param + ")";:}
                    ;

FORMAL_PARAM::= VARLIST:varlist colons ALLTYPES:alltypes                                       {: pushRegla("FORMAL_PARAM <%VARLIST : ALLTYPES%>");
                                                                                                  RESULT = varlist + ":" + alltypes;:}
               | VARLIST:varlist colons ALLTYPES:alltypes semicolons FORMAL_PARAM:formal_param {: pushRegla("FORMAL_PARAM <%VARLIST : ALLTYPES ; FORMAL_PARAM%>");
                                                                                                  RESULT = varlist + ":" + alltypes + ";" + formal_param;:}
               ;

TBAS::= int_name    {: pushRegla("TBAS <%INTEGER%>");
                       RESULT = htmlGenerator.getReservedWord(" INTEGER");:}
        | real_name {: pushRegla("TBAS <%REAL%>");
                       RESULT = htmlGenerator.getReservedWord(" REAL");:}
        | char_name {: pushRegla("TBAS <%CHAR%>");
                       RESULT = htmlGenerator.getReservedWord(" CHARACTER");:}
        ;

SENT::= ASIG:asig semicolons              {: pushRegla("SENT <%ASIG ;%>");
                                             RESULT = htmlGenerator.getSent(asig + ";", htmlGenerator.sentCond);:}
        | PROC_CALL:proc_call semicolons  {: pushRegla("SENT <%PROC_CALL ;%>");
                                             RESULT = htmlGenerator.getSent(proc_call + ";", htmlGenerator.sentCond);:}
        | EXEBLQ:exeblq                   {: pushRegla("SENT <%EXEBLQ%>");
                                             RESULT = exeblq;:}
        | COND:cond                       {: pushRegla("SENT <%COND%>");
                                             RESULT = htmlGenerator.getSent(cond);:}
        | WLOOP:wloop                     {: pushRegla("SENT <%WLOOP%>");
                                             RESULT = htmlGenerator.getSent(wloop);:}
        | FLOOP:floop                     {: pushRegla("SENT <%FLOOP%>");
                                             RESULT = htmlGenerator.getSent(floop);:}
        | CASE:case_t                       {: pushRegla("SENT <%CASE%>");
                                             RESULT = htmlGenerator.getSent(case_t);:}
        ;

ASIG::= ID:id asig EXP:exp {: pushRegla("ASIG <%ID := EXP%>");
                              RESULT = id + " := " + exp;:};

ID::= identifier:i1                                                    {: pushRegla("ID <%"+i1+"%>");
                                                                          RESULT = htmlGenerator.getIdent(i1);:}
      | identifier:i4 open_square_bracket EXP:exp close_square_bracket {: pushRegla("ID <%"+i4+" [ EXP ]%>");
                                                                          RESULT = htmlGenerator.getIdent(i4) + "[ " + exp + " ]";:}
      | identifier:i2 point identifier:i3                              {: pushRegla("ID <%"+i2+" . "+i3+"%>");
                                                                          RESULT = htmlGenerator.getIdent(i2) + "." + htmlGenerator.getIdent(i3);:}
      ;

EXP::= EXP:exp1 OP:op EXP:exp2 {: pushRegla("EXP <%EXP OP EXP%>");
                                  RESULT = (String)exp1 + op + (String)exp2;:}
       | FACTOR:factor         {: pushRegla("EXP <%FACTOR%>");
                                  RESULT = factor;:}
       ;

OP::= OPCOMP:opcomp   {: pushRegla("OP <%OPCOMP%>");
                         RESULT = opcomp;:}
      | OPLOG:oplog   {: pushRegla("OP <%OPLOG%>");
                         RESULT = oplog;:}
      | OPARIT:oparit {: pushRegla("OP <%OPARIT%>");
                         RESULT = oparit;:}
      ;

OPCOMP::= comparator_op:op {: pushRegla("OPCOMP <%"+op+"%>");
                              RESULT = op;:};

OPARIT::= plus       {: pushRegla("OPARIT <%+%>");
                        RESULT = " + ";:}
          | minus    {: pushRegla("OPARIT <%-%>");
                        RESULT = " - ";:}
          | product  {: pushRegla("OPARIT <%*%>");
                        RESULT = " * ";:}
          | div_op   {: pushRegla("OPARIT <%div%>");
                        RESULT = " div ";:}
          | mod_op   {: pushRegla("OPARIT <%mod%>");
                        RESULT = " mod ";:}
          ;


OPLOG::= and_op    {: pushRegla("OPLOG <%and%>");
                      RESULT = "and";:}
          | or_op  {: pushRegla("OPLOG <%or%>");
                      RESULT = "or";:}
          ;

FACTOR::= SIMPVALUE:simpvalue                                                {: pushRegla("FACTOR <%SIMPVALUE%>");
                                                                                RESULT = simpvalue;:}
          | not_op FACTOR:factor                                             {: pushRegla("FACTOR <%not FACTOR%>");
                                                                                RESULT = "not" + factor;:}
          | open_bracket EXP:exp close_bracket                               {: pushRegla("FACTOR <%( EXP )%>");
                                                                                RESULT = "(" + exp + ")";:}
          | identifier:i1 SUBPARAMLIST:subparamlist                          {: pushRegla("FACTOR <%"+i1+" SUBPARAMLIST%>");
                                                                                RESULT = htmlGenerator.getIdent(i1) + (String)subparamlist;:}
          | identifier:i2 open_square_bracket EXP:exp close_square_bracket   {: pushRegla("FACTOR <%"+i2+" [ EXP ]%>");
                                                                                RESULT = htmlGenerator.getIdent(i2) + "[" + exp + "]";:}
          | identifier:i3 point identifier:i4                                {: pushRegla("FACTOR <%"+i3+" . "+i4+"%>");
                                                                                RESULT = htmlGenerator.getIdent(i3) + "." + htmlGenerator.getIdent(i4);:}
          ;

SUBPARAMLIST::=                                              {: pushRegla("SUBPARAMLIST <%lambda%>");
                                                                RESULT = "";:}
                | open_bracket EXPLIST:explist close_bracket {: pushRegla("SUBPARAMLIST <%( EXPLIST )%>");
                                                                RESULT = " (" + explist + ") ";:}
                ;

EXPLIST::= EXP:exp                        {: pushRegla("EXPLIST <%EXP%>");
                                             RESULT = exp;:}
          | EXP:exp comma EXPLIST:explist {: pushRegla("EXPLIST <%EXP , EXPLIST%>");
                                             RESULT = exp + "," + explist;:}
          ;

PROC_CALL::= identifier:i1 SUBPARAMLIST:subparamlist {: pushRegla("PROC_CALL <%"+i1+" SUBPARAMLIST%>");
                                                        RESULT = htmlGenerator.getIdent(i1) + (String)subparamlist;:};
EXEBLQ::= DCLLIST_BLQ:dcllist_blq begin {:htmlGenerator.identLevel++;:} SENTLIST:sentlist end {:
                                                                 htmlGenerator.identLevel--;
                                                                 pushRegla("EXEBLQ <%DCLLIST_BLQ begin SENTLIST end%>");
                                                                 RESULT = dcllist_blq + htmlGenerator.getReservedWordIdent("begin") + sentlist + htmlGenerator.getReservedWordIdent("end");:};

DCLLIST_BLQ::=                                   {: pushRegla("DCLLIST_BLQ <%lambda%>");
                                                    RESULT = "";:}
               | DCLLIST_BLQ:dcllist_blq semicolons DCL_BLQ:dcl_blq  {: pushRegla("DCLLIST_BLQ <%DCLLIST_BLQ ; DCL_BLQ%>");
                                                                        RESULT = dcllist_blq + ";" + dcl_blq;:}
               ;

DCL_BLQ::= DEFCTE:defcte     {: pushRegla("DCL_BLQ <%DEFCTE%>");
                                RESULT = defcte;:}
           | DEFVAR:defvar   {: pushRegla("DCL_BLQ <%DEFVAR%>");
                                RESULT = defvar;:}
           | DEFTYPE:deftype {: pushRegla("DCL_BLQ <%DEFTYPE%>");
                                RESULT = deftype;:}
           ;

/* ------------ SINTAXIS ESTRUCTURAS DE DATOS  ----------- */

DEFTYPE ::= type TYPELIST:typelist {: pushRegla("DEFTYPE <%type TYPELIST%>");
                                      RESULT = htmlGenerator.getReservedWord("type ") + typelist;:};

TYPELIST ::= identifier:i1 equal UDTYPE:udtype semicolons                       {: pushRegla("TYPELIST <%"+i1+" = UDTYPE ;%>");
                                                                                   RESULT = htmlGenerator.getIdent(i1) + " = " + udtype + ";";:}
              | identifier:i2 equal UDTYPE:udtype semicolons TYPELIST:typelist  {: pushRegla("TYPELIST <%"+i2+" = UDTYPE ; TYPELIST%>");
                                                                                   RESULT = htmlGenerator.getIdent(i2) + " = " + udtype + ";" + typelist;:}
              ;

UDTYPE ::= array open_square_bracket SIMPVALUE:simpvalue1 two_points SIMPVALUE:simpvalue2 close_square_bracket of ALLTYPES:alltypes {:
                    pushRegla("UDTYPE <%array [ SIMPVALUE .. SIMPVALUE ] of ALLTYPES%>");
                    RESULT = htmlGenerator.getReservedWord("array ") + "[ " + simpvalue1 + " .. " + simpvalue2 + " ]" + htmlGenerator.getReservedWord(" of ") + alltypes;:}
              | record DEFVARLIST:defvarlist end {:
                    pushRegla("UDTYPE <%record DEFVARLIST end%>");
                    RESULT = htmlGenerator.getReservedWord("record ") + defvarlist + htmlGenerator.getReservedWord("end");:}
              ;

ALLTYPES ::= TBAS:tbas          {: pushRegla("ALLTYPES <%TBAS%>");
                                RESULT = tbas;:}
             | identifier:i  {: pushRegla("ALLTYPES <%"+i+"%>");
                                RESULT = htmlGenerator.getIdent(i);:}
             ;

/* ------------ SINTAXIS SENTENCIAS DE CONTROL DE FLUJO  ----------- */

                         /* SENTENCIA IF */

COND ::= if_t EXP:exp then_t {: htmlGenerator.sentCond = true; :} SENT:sent ELSECOND:elsecond {: pushRegla("COND <%if EXP then SENT ELSECOND%>");
                                                            RESULT = htmlGenerator.getReservedWord("if ") + exp + htmlGenerator.getReservedWord(" then ") + sent + elsecond;:};

ELSECOND ::=                    {: pushRegla("ELSECOND <%lambda%>");
                                   RESULT = "";:}
            | else_t SENT:sent  {: pushRegla("ELSECOND <%else SENT%>");
                                   RESULT = htmlGenerator.getReservedWord("else ") + sent;:}
            ;

                        /* SENTENCIA WHILE */

WLOOP ::= while_t EXP:exp do_t  {: htmlGenerator.sentCond = true; :} SENT:sent {: pushRegla("WLOOP <%while EXP do SENT%>");
                                            RESULT = htmlGenerator.getReservedWord("while ") + exp + htmlGenerator.getReservedWord(" do ") + sent;:};

                        /* SENTENCIA FOR  */

FLOOP ::= for_t identifier:i1 asig EXP:exp1 to EXP:exp2 do_t {: htmlGenerator.sentCond = true; :} SENT:sent {: pushRegla("FLOOP <%for "+i1+" := EXP to EXP do SENT%>");
                                                                          RESULT = htmlGenerator.getReservedWord("for") + htmlGenerator.getIdent(i1) +
                                                                          ":=" + exp1 + htmlGenerator.getReservedWord("to") + exp2 + htmlGenerator.getReservedWord("do") + sent;:};

                        /* SENTENCIA CASE */

CASE ::= case_t EXP:exp of CASELIST:caselist end {: pushRegla("CASE <%case EXP of CASELIST end%>");
                                                    RESULT = htmlGenerator.getReservedWord("case") + exp + htmlGenerator.getReservedWord("of") +
                                                    caselist + htmlGenerator.getReservedWord("end");:};

CASELIST ::= EXP:exp colons SENT:sent                     {: pushRegla("CASELIST <%EXP : SENT%>");
                                                             RESULT = exp + " : " + sent;:}
             | EXP:exp colons SENT:sent CASELIST:caselist {: pushRegla("CASELIST <%EXP : SENT CASELIST%>");
                                                             RESULT = exp + " : " + sent + caselist;:}
             ;
